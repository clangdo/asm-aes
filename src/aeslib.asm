	%define MIX_COLUMNS_POLY 0x03010102 ;From the aes spec (eq. 5.5)

	%macro prologue 0
	push rbp
	mov rbp,rsp
	push rbx
	push r12
	push r13
	push r14
	push r15
	%endmacro
	
	%macro epilogue 0
	pop r15
	pop r14
	pop r13
	pop r12
	pop rbx
	mov rsp,rbp
	pop rbp
	%endmacro

	;; The first argument is the state pointer,
	;; the second is the row index (0, 1, 2, or 3 only).
	%macro move_row_to_r10d 1
	push rcx
	xor rcx,rcx
%%move_column_to_nextbyte:
	mov r10b,[%1 + rcx * 4]
	ror r10d,0x8
	inc rcx
	cmp rcx,0x4
	jb %%move_column_to_nextbyte
	pop rcx
	%endmacro
	
	%macro move_r10d_to_row 1
	push rcx
	xor rcx,rcx
%%move_eax_to_nextbyte:
	mov [%1 + rcx * 4],r10b
	ror r10d,0x8
	inc rcx
	cmp rcx,0x4
	jb %%move_eax_to_nextbyte
	pop rcx
	%endmacro

	%macro rotword 1
	%endmacro

	%macro subword 1
	%endmacro

	%macro move_r12d_rcon 2
	%endmacro

section .data
	;; The sbox is defined in the aes standard, and shown in section 5.1.1
	sbox db 0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\
		0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\
		0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\
		0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\
		0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\
		0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\
		0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\
		0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\
		0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\
		0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\
		0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\
		0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\
		0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\
		0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\
		0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\
		0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16

section .text	
	global aes_encrypt
	global aes_shift_rows
	global aes_add_round_key
	global aes_mix_columns
	global aes_sub_bytes

	extern aes_mul_gf28
	extern aes_mul_poly
	
;;; Expands a given key to a key schedule
aes_key_expand:
	prologue
	xor rcx,rcx
aes_key_expand_initial_next:
	mov r11,[rdi + rcx * 4]
	mov [rsi + rcx * 4],r11
	inc rcx
	cmp rcx,rdx
	jb aes_key_expand_initial_next

aes_key_expand_next:
	mov ebx,[rsi + rcx - 1]
	mov ax,cx
	div dl
	cmp ah,0
	jne aes_key_expand_over_1
	push rdx
	rotword ebx
	subword ebx
	move_r12d_rcon rcx,rdx
	xor ebx,r12d
	pop rdx
aes_key_expand_over_1:
	cmp rdx,0x6
	jb aes_key_expand_over_2
	cmp ah,0x4
	jne aes_key_expand_over_2
	subword ebx
aes_key_expand_over_2:
	inc rcx
	cmp rcx,rdx		;TODO:fix
	epilogue
	ret
	
;;; Not yet implemented
aes_decrypt:
	prologue
	epilogue
	ret

;;; This does the shift rows thingy, a pointer to the state must be passed through rdi
aes_shift_rows:
	prologue
	mov rcx,0x1
aes_shift_rows_next:
	lea r11,[rdi + rcx]
	move_row_to_r10d r11
	mov al,0x8
	mul cl
	push rcx

	mov cl,al
	ror r10d,cl
	pop rcx
	
	move_r10d_to_row r11
	inc rcx
	cmp rcx,0x4
	jb aes_shift_rows_next
	epilogue
	ret

;;; aes_add_round_key xors the state with the 4 double word sized "words" of the key schedule
;;; rdi contains a pointer to the state
;;; rsi contains a pointer to the key schedule
;;; rdx contains an offset in the key schedule with which to start
aes_add_round_key:
	prologue
	xor r9,r9		;Counter
	lea r13,[rsi + rdx * 4]
aes_add_round_key_next:
	mov r10d,[rdi + r9 * 4]
	mov r12d,[r13 + r9 * 4]
	xor r10d,r12d
	mov [rdi + r9 * 4],r10d
	inc r9
	cmp r9,0x4
	jb aes_add_round_key_next
	epilogue
	ret

aes_mix_columns:
	prologue
	xor rcx,rcx
	xor rbx,rbx
aes_mix_columns_next:
	xor r10,r10
	mov r10d,dword[rdi + rcx*4]
	push rdi
	push rsi
	push rcx
	
	mov rdi,r10
	mov rsi,MIX_COLUMNS_POLY
	call aes_mul_poly
	
	pop rcx
	pop rsi
	pop rdi
	mov [rdi + rcx*4],eax
	inc rcx
	cmp rcx,0x4
	jb aes_mix_columns_next
	epilogue
	ret
	
aes_sub_bytes:
	prologue
	mov rcx,16
aes_sub_bytes_next:
	lea r13,[rdi + rcx]
	dec r13
	movzx r15,byte[r13]
	movzx r14,byte[sbox + r15]
	mov byte[r13],r14b
	loop aes_sub_bytes_next
	epilogue
	ret
	
;;; aes_encrypt takes a 128 bit state and encrypts it using the given key schedule and Nr
;;; Parameters:
;;; 	rdi contains a pointer to the state array
;;; 	rsi contains a pointer to the key schedule array
;;; 	rcx contains Nr (per aes standard)
aes_encrypt:
	prologue

	mov r10,rcx
	xor rcx,rcx
	call aes_add_round_key
	inc rcx
aes_encrypt_next_round:
	call aes_sub_bytes
	call aes_shift_rows
	call aes_mix_columns
	
	call aes_add_round_key	;This one takes rdi, rsi, and rcx, the rest just take rdi
	
	inc rcx
	cmp rcx,r10
	jb aes_encrypt_next_round

	call aes_sub_bytes
	call aes_shift_rows
	call aes_add_round_key	;Here rcx is already correct since it will contain Nr
	epilogue
	ret
